/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Add;
import org.xtext.example.mydsl.myDsl.AltAttribute;
import org.xtext.example.mydsl.myDsl.AtomicNumber;
import org.xtext.example.mydsl.myDsl.Attribute;
import org.xtext.example.mydsl.myDsl.AttributeValues;
import org.xtext.example.mydsl.myDsl.Attributes;
import org.xtext.example.mydsl.myDsl.BattleSize;
import org.xtext.example.mydsl.myDsl.Div;
import org.xtext.example.mydsl.myDsl.EType;
import org.xtext.example.mydsl.myDsl.Entities;
import org.xtext.example.mydsl.myDsl.Entity;
import org.xtext.example.mydsl.myDsl.EntityMoves;
import org.xtext.example.mydsl.myDsl.Loc;
import org.xtext.example.mydsl.myDsl.Locations;
import org.xtext.example.mydsl.myDsl.Members;
import org.xtext.example.mydsl.myDsl.Move;
import org.xtext.example.mydsl.myDsl.Moves;
import org.xtext.example.mydsl.myDsl.Mult;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.NumberComparing;
import org.xtext.example.mydsl.myDsl.Relations;
import org.xtext.example.mydsl.myDsl.Rule;
import org.xtext.example.mydsl.myDsl.Sub;
import org.xtext.example.mydsl.myDsl.Team;
import org.xtext.example.mydsl.myDsl.Teams;
import org.xtext.example.mydsl.myDsl.Type;
import org.xtext.example.mydsl.myDsl.TypeExpression;
import org.xtext.example.mydsl.myDsl.and;
import org.xtext.example.mydsl.myDsl.or;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ADD:
				sequence_Sum(context, (Add) semanticObject); 
				return; 
			case MyDslPackage.ALT_ATTRIBUTE:
				sequence_AltAttribute(context, (AltAttribute) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_NUMBER:
				sequence_AtomicNumber(context, (AtomicNumber) semanticObject); 
				return; 
			case MyDslPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case MyDslPackage.ATTRIBUTE_VALUES:
				sequence_AttributeValues(context, (AttributeValues) semanticObject); 
				return; 
			case MyDslPackage.ATTRIBUTES:
				sequence_Attributes(context, (Attributes) semanticObject); 
				return; 
			case MyDslPackage.BATTLE_SIZE:
				sequence_BattleSize(context, (BattleSize) semanticObject); 
				return; 
			case MyDslPackage.DIV:
				sequence_Multiply(context, (Div) semanticObject); 
				return; 
			case MyDslPackage.ETYPE:
				sequence_EType(context, (EType) semanticObject); 
				return; 
			case MyDslPackage.ENTITIES:
				sequence_Entities(context, (Entities) semanticObject); 
				return; 
			case MyDslPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case MyDslPackage.ENTITY_MOVES:
				sequence_EntityMoves(context, (EntityMoves) semanticObject); 
				return; 
			case MyDslPackage.LOC:
				sequence_Loc(context, (Loc) semanticObject); 
				return; 
			case MyDslPackage.LOCATIONS:
				sequence_Locations(context, (Locations) semanticObject); 
				return; 
			case MyDslPackage.MEMBERS:
				sequence_Members(context, (Members) semanticObject); 
				return; 
			case MyDslPackage.MOVE:
				sequence_Move(context, (Move) semanticObject); 
				return; 
			case MyDslPackage.MOVES:
				sequence_Moves(context, (Moves) semanticObject); 
				return; 
			case MyDslPackage.MULT:
				sequence_Multiply(context, (Mult) semanticObject); 
				return; 
			case MyDslPackage.NUMBER_COMPARING:
				if (rule == grammarAccess.getRequireRule()
						|| rule == grammarAccess.getORconditionRule()
						|| action == grammarAccess.getORconditionAccess().getOrLeftAction_1_1()
						|| rule == grammarAccess.getANDconditionRule()
						|| action == grammarAccess.getANDconditionAccess().getAndLeftAction_1_1()
						|| rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getNumberComparingRule()) {
					sequence_NumberComparing(context, (NumberComparing) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getTeamsRule()) {
					sequence_NumberComparing_Teams(context, (NumberComparing) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.RELATIONS:
				sequence_Relations(context, (Relations) semanticObject); 
				return; 
			case MyDslPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case MyDslPackage.SUB:
				sequence_Sum(context, (Sub) semanticObject); 
				return; 
			case MyDslPackage.SYSTEM:
				sequence_System(context, (org.xtext.example.mydsl.myDsl.System) semanticObject); 
				return; 
			case MyDslPackage.TEAM:
				sequence_Team(context, (Team) semanticObject); 
				return; 
			case MyDslPackage.TEAMS:
				sequence_Teams(context, (Teams) semanticObject); 
				return; 
			case MyDslPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case MyDslPackage.TYPE_EXPRESSION:
				sequence_TypeExpression(context, (TypeExpression) semanticObject); 
				return; 
			case MyDslPackage.AND:
				if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getTeamsRule()) {
					sequence_ANDcondition_Teams(context, (and) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRequireRule()
						|| rule == grammarAccess.getORconditionRule()
						|| action == grammarAccess.getORconditionAccess().getOrLeftAction_1_1()
						|| rule == grammarAccess.getANDconditionRule()
						|| action == grammarAccess.getANDconditionAccess().getAndLeftAction_1_1()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ANDcondition(context, (and) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.OR:
				if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getTeamsRule()) {
					sequence_ORcondition_Teams(context, (or) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRequireRule()
						|| rule == grammarAccess.getORconditionRule()
						|| action == grammarAccess.getORconditionAccess().getOrLeftAction_1_1()
						|| rule == grammarAccess.getANDconditionRule()
						|| action == grammarAccess.getANDconditionAccess().getAndLeftAction_1_1()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ORcondition(context, (or) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Declaration returns and
	 *     Teams returns and
	 *
	 * Constraint:
	 *     (left=ANDcondition_and_1_1 right=Statement bs=BattleSize team+=Team+)
	 */
	protected void sequence_ANDcondition_Teams(ISerializationContext context, and semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Require returns and
	 *     ORcondition returns and
	 *     ORcondition.or_1_1 returns and
	 *     ANDcondition returns and
	 *     ANDcondition.and_1_1 returns and
	 *     Statement returns and
	 *
	 * Constraint:
	 *     (left=ANDcondition_and_1_1 right=Statement)
	 */
	protected void sequence_ANDcondition(ISerializationContext context, and semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getANDconditionAccess().getAndLeftAction_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getANDconditionAccess().getRightStatementParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AltAttribute returns AltAttribute
	 *
	 * Constraint:
	 *     (attriburte+=[Attribute|ID]+ av=AttributeValues?)
	 */
	protected void sequence_AltAttribute(ISerializationContext context, AltAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns AtomicNumber
	 *     Sum.Add_1_0_0_1 returns AtomicNumber
	 *     Sum.Sub_1_0_1_1 returns AtomicNumber
	 *     Multiply returns AtomicNumber
	 *     Multiply.Mult_1_0_0_1 returns AtomicNumber
	 *     Multiply.Div_1_0_1_1 returns AtomicNumber
	 *     AtomicNumber returns AtomicNumber
	 *
	 * Constraint:
	 *     (value=Float | value2=INT)
	 */
	protected void sequence_AtomicNumber(ISerializationContext context, AtomicNumber semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeValues returns AttributeValues
	 *
	 * Constraint:
	 *     (lTypes=LegalType | value=AtomicNumber | rule=Rule | require=Require)
	 */
	protected void sequence_AttributeValues(ISerializationContext context, AttributeValues semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID aVal=AttributeValues)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATTRIBUTE__AVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATTRIBUTE__AVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getAValAttributeValuesParserRuleCall_2_0(), semanticObject.getAVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Attributes
	 *     Attributes returns Attributes
	 *
	 * Constraint:
	 *     attribute+=Attribute+
	 */
	protected void sequence_Attributes(ISerializationContext context, Attributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BattleSize returns BattleSize
	 *
	 * Constraint:
	 *     (value=AtomicNumber req=Require?)
	 */
	protected void sequence_BattleSize(ISerializationContext context, BattleSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EType returns EType
	 *
	 * Constraint:
	 *     type=[Type|ID]
	 */
	protected void sequence_EType(ISerializationContext context, EType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ETYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ETYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getETypeAccess().getTypeTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.ETYPE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Entities
	 *     Entities returns Entities
	 *
	 * Constraint:
	 *     entity+=Entity+
	 */
	protected void sequence_Entities(ISerializationContext context, Entities semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityMoves returns EntityMoves
	 *
	 * Constraint:
	 *     move+=[Move|ID]+
	 */
	protected void sequence_EntityMoves(ISerializationContext context, EntityMoves semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=ID eType=EType att+=AltAttribute* eMoves+=EntityMoves*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Loc returns Loc
	 *
	 * Constraint:
	 *     (name=ID oname=ID)
	 */
	protected void sequence_Loc(ISerializationContext context, Loc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOC__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOC__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOC__ONAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOC__ONAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocAccess().getOnameIDTerminalRuleCall_2_0(), semanticObject.getOname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Locations
	 *     Locations returns Locations
	 *
	 * Constraint:
	 *     loc+=Loc+
	 */
	protected void sequence_Locations(ISerializationContext context, Locations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Members returns Members
	 *
	 * Constraint:
	 *     entity+=[Entity|ID]+
	 */
	protected void sequence_Members(ISerializationContext context, Members semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Move returns Move
	 *
	 * Constraint:
	 *     (name=ID eType=EType att+=AltAttribute*)
	 */
	protected void sequence_Move(ISerializationContext context, Move semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Moves
	 *     Moves returns Moves
	 *
	 * Constraint:
	 *     move+=Move+
	 */
	protected void sequence_Moves(ISerializationContext context, Moves semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns Div
	 *     Sum.Add_1_0_0_1 returns Div
	 *     Sum.Sub_1_0_1_1 returns Div
	 *     Multiply returns Div
	 *     Multiply.Mult_1_0_0_1 returns Div
	 *     Multiply.Div_1_0_1_1 returns Div
	 *
	 * Constraint:
	 *     (left=Multiply_Div_1_0_1_1 right=AtomicNumber)
	 */
	protected void sequence_Multiply(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplyAccess().getDivLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplyAccess().getRightAtomicNumberParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns Mult
	 *     Sum.Add_1_0_0_1 returns Mult
	 *     Sum.Sub_1_0_1_1 returns Mult
	 *     Multiply returns Mult
	 *     Multiply.Mult_1_0_0_1 returns Mult
	 *     Multiply.Div_1_0_1_1 returns Mult
	 *
	 * Constraint:
	 *     (left=Multiply_Mult_1_0_0_1 right=AtomicNumber)
	 */
	protected void sequence_Multiply(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULT__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplyAccess().getMultLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplyAccess().getRightAtomicNumberParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Require returns NumberComparing
	 *     ORcondition returns NumberComparing
	 *     ORcondition.or_1_1 returns NumberComparing
	 *     ANDcondition returns NumberComparing
	 *     ANDcondition.and_1_1 returns NumberComparing
	 *     Statement returns NumberComparing
	 *     NumberComparing returns NumberComparing
	 *
	 * Constraint:
	 *     (left=Sum comp=Comparator right=Sum)
	 */
	protected void sequence_NumberComparing(ISerializationContext context, NumberComparing semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NUMBER_COMPARING__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NUMBER_COMPARING__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NUMBER_COMPARING__COMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NUMBER_COMPARING__COMP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NUMBER_COMPARING__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NUMBER_COMPARING__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberComparingAccess().getLeftSumParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNumberComparingAccess().getCompComparatorParserRuleCall_1_0(), semanticObject.getComp());
		feeder.accept(grammarAccess.getNumberComparingAccess().getRightSumParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns NumberComparing
	 *     Teams returns NumberComparing
	 *
	 * Constraint:
	 *     (left=Sum comp=Comparator right=Sum bs=BattleSize team+=Team+)
	 */
	protected void sequence_NumberComparing_Teams(ISerializationContext context, NumberComparing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns or
	 *     Teams returns or
	 *
	 * Constraint:
	 *     (left=ORcondition_or_1_1 right=ANDcondition bs=BattleSize team+=Team+)
	 */
	protected void sequence_ORcondition_Teams(ISerializationContext context, or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Require returns or
	 *     ORcondition returns or
	 *     ORcondition.or_1_1 returns or
	 *     ANDcondition returns or
	 *     ANDcondition.and_1_1 returns or
	 *     Statement returns or
	 *
	 * Constraint:
	 *     (left=ORcondition_or_1_1 right=ANDcondition)
	 */
	protected void sequence_ORcondition(ISerializationContext context, or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getORconditionAccess().getOrLeftAction_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getORconditionAccess().getRightANDconditionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Relations
	 *     Relations returns Relations
	 *
	 * Constraint:
	 *     type+=Type+
	 */
	protected void sequence_Relations(ISerializationContext context, Relations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|ID] 
	 *         comp=Comparator 
	 *         value=AtomicNumber 
	 *         attribute2=[Attribute|ID] 
	 *         sum=Sum 
	 *         val=AtomicNumber
	 *     )
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RULE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RULE__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RULE__COMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RULE__COMP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RULE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RULE__VALUE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RULE__ATTRIBUTE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RULE__ATTRIBUTE2));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RULE__SUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RULE__SUM));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RULE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RULE__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleAccess().getAttributeAttributeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.RULE__ATTRIBUTE, false));
		feeder.accept(grammarAccess.getRuleAccess().getCompComparatorParserRuleCall_2_0(), semanticObject.getComp());
		feeder.accept(grammarAccess.getRuleAccess().getValueAtomicNumberParserRuleCall_3_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getRuleAccess().getAttribute2AttributeIDTerminalRuleCall_5_0_1(), semanticObject.eGet(MyDslPackage.Literals.RULE__ATTRIBUTE2, false));
		feeder.accept(grammarAccess.getRuleAccess().getSumSumParserRuleCall_6_0(), semanticObject.getSum());
		feeder.accept(grammarAccess.getRuleAccess().getValAtomicNumberParserRuleCall_7_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns Add
	 *     Sum.Add_1_0_0_1 returns Add
	 *     Sum.Sub_1_0_1_1 returns Add
	 *
	 * Constraint:
	 *     (left=Sum_Add_1_0_0_1 right=Multiply)
	 */
	protected void sequence_Sum(ISerializationContext context, Add semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADD__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADD__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADD__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADD__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getAddLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSumAccess().getRightMultiplyParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns Sub
	 *     Sum.Add_1_0_0_1 returns Sub
	 *     Sum.Sub_1_0_1_1 returns Sub
	 *
	 * Constraint:
	 *     (left=Sum_Sub_1_0_1_1 right=Multiply)
	 */
	protected void sequence_Sum(ISerializationContext context, Sub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SUB__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SUB__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SUB__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SUB__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getSubLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSumAccess().getRightMultiplyParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (name=ID declarations+=Declaration*)
	 */
	protected void sequence_System(ISerializationContext context, org.xtext.example.mydsl.myDsl.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Team returns Team
	 *
	 * Constraint:
	 *     (name=ID members+=Members+)
	 */
	protected void sequence_Team(ISerializationContext context, Team semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Teams
	 *     Teams returns Teams
	 *
	 * Constraint:
	 *     (bs=BattleSize team+=Team+)
	 */
	protected void sequence_Teams(ISerializationContext context, Teams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeExpression returns TypeExpression
	 *
	 * Constraint:
	 *     type=ID
	 */
	protected void sequence_TypeExpression(ISerializationContext context, TypeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeExpressionAccess().getTypeIDTerminalRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
