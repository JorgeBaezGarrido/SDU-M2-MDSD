/**
 * generated by Xtext 2.21.0
 */
package mdsd.generator;

import com.google.common.collect.Iterators;
import java.util.Arrays;
import mdsd.rPG.Add;
import mdsd.rPG.And;
import mdsd.rPG.Bigger;
import mdsd.rPG.BiggerEq;
import mdsd.rPG.Comparator;
import mdsd.rPG.Death;
import mdsd.rPG.Declaration;
import mdsd.rPG.Div;
import mdsd.rPG.Eq;
import mdsd.rPG.FloatNum;
import mdsd.rPG.IntNum;
import mdsd.rPG.Mult;
import mdsd.rPG.NEq;
import mdsd.rPG.NameAttribute;
import mdsd.rPG.NumberComparing;
import mdsd.rPG.Or;
import mdsd.rPG.Proposition;
import mdsd.rPG.Require;
import mdsd.rPG.Smaller;
import mdsd.rPG.SmallerEq;
import mdsd.rPG.Sub;
import mdsd.rPG.Sum;
import mdsd.rPG.SystemRPG;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class RPGGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final SystemRPG game = Iterators.<SystemRPG>filter(resource.getAllContents(), SystemRPG.class).next();
    this.ds(game);
  }
  
  public void ds(final SystemRPG system) {
    EList<Declaration> _declarations = system.getDeclarations();
    for (final Declaration d : _declarations) {
      boolean _matched = false;
      if (d instanceof Death) {
        _matched=true;
        this.deaths(((Death)d));
      }
      if (!_matched) {
        System.out.println("");
      }
    }
  }
  
  public void deaths(final Death death) {
    this.re(death.getReq());
  }
  
  public void re(final Require req) {
    System.out.println(this.logic(req.getLog()));
  }
  
  protected CharSequence _logic(final Or x) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _logic = this.logic(x.getLeft());
    _builder.append(_logic);
    _builder.append("||");
    CharSequence _logic_1 = this.logic(x.getRight());
    _builder.append(_logic_1);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _logic(final And x) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _logic = this.logic(x.getLeft());
    _builder.append(_logic);
    _builder.append("&&");
    CharSequence _logic_1 = this.logic(x.getRight());
    _builder.append(_logic_1);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _logic(final NumberComparing x) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _exp = this.exp(x.getLeft());
    _builder.append(_exp);
    String _generateComp = this.generateComp(x.getComp());
    _builder.append(_generateComp);
    CharSequence _exp_1 = this.exp(x.getRight());
    _builder.append(_exp_1);
    _builder.append(")");
    return _builder;
  }
  
  public String generateComp(final Comparator op) {
    String _switchResult = null;
    boolean _matched = false;
    if (op instanceof Eq) {
      _matched=true;
      _switchResult = "==";
    }
    if (!_matched) {
      if (op instanceof Smaller) {
        _matched=true;
        _switchResult = "<";
      }
    }
    if (!_matched) {
      if (op instanceof Bigger) {
        _matched=true;
        _switchResult = ">";
      }
    }
    if (!_matched) {
      if (op instanceof SmallerEq) {
        _matched=true;
        _switchResult = "<=";
      }
    }
    if (!_matched) {
      if (op instanceof BiggerEq) {
        _matched=true;
        _switchResult = ">=";
      }
    }
    if (!_matched) {
      if (op instanceof NEq) {
        _matched=true;
        _switchResult = "!=";
      }
    }
    return _switchResult;
  }
  
  protected CharSequence _exp(final Add x) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _exp = this.exp(x.getLeft());
    _builder.append(_exp);
    _builder.append("+");
    CharSequence _exp_1 = this.exp(x.getRight());
    _builder.append(_exp_1);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _exp(final Sub x) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _exp = this.exp(x.getLeft());
    _builder.append(_exp);
    _builder.append("-");
    CharSequence _exp_1 = this.exp(x.getRight());
    _builder.append(_exp_1);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _exp(final Mult x) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _exp = this.exp(x.getLeft());
    _builder.append(_exp);
    _builder.append("*");
    CharSequence _exp_1 = this.exp(x.getRight());
    _builder.append(_exp_1);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _exp(final Div x) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _exp = this.exp(x.getLeft());
    _builder.append(_exp);
    _builder.append("/");
    CharSequence _exp_1 = this.exp(x.getRight());
    _builder.append(_exp_1);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _exp(final IntNum x) {
    return Integer.toString(x.getValue());
  }
  
  protected CharSequence _exp(final FloatNum x) {
    String _string = Integer.toString(x.getI());
    String _plus = (_string + ".");
    String _string_1 = Integer.toString(x.getDecimal());
    return (_plus + _string_1);
  }
  
  protected CharSequence _exp(final NameAttribute x) {
    String _name = x.getAttribute().getName();
    return ("_" + _name);
  }
  
  public CharSequence logic(final Proposition x) {
    if (x instanceof And) {
      return _logic((And)x);
    } else if (x instanceof NumberComparing) {
      return _logic((NumberComparing)x);
    } else if (x instanceof Or) {
      return _logic((Or)x);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(x).toString());
    }
  }
  
  public CharSequence exp(final Sum x) {
    if (x instanceof FloatNum) {
      return _exp((FloatNum)x);
    } else if (x instanceof IntNum) {
      return _exp((IntNum)x);
    } else if (x instanceof NameAttribute) {
      return _exp((NameAttribute)x);
    } else if (x instanceof Div) {
      return _exp((Div)x);
    } else if (x instanceof Mult) {
      return _exp((Mult)x);
    } else if (x instanceof Add) {
      return _exp((Add)x);
    } else if (x instanceof Sub) {
      return _exp((Sub)x);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(x).toString());
    }
  }
}
