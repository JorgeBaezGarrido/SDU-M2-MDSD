/*
 * generated by Xtext 2.21.0
 */
package mdsd.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mdsd.rPG.Add;
import mdsd.rPG.AltAttribute;
import mdsd.rPG.And;
import mdsd.rPG.AtomicAttribute;
import mdsd.rPG.AtomicNumber;
import mdsd.rPG.Attribute;
import mdsd.rPG.AttributeValues;
import mdsd.rPG.Attributes;
import mdsd.rPG.Death;
import mdsd.rPG.Div;
import mdsd.rPG.EType;
import mdsd.rPG.Entities;
import mdsd.rPG.Entity;
import mdsd.rPG.EntityMoves;
import mdsd.rPG.Loc;
import mdsd.rPG.Locations;
import mdsd.rPG.Members;
import mdsd.rPG.Move;
import mdsd.rPG.Moves;
import mdsd.rPG.Mult;
import mdsd.rPG.Or;
import mdsd.rPG.Proposition;
import mdsd.rPG.RPGPackage;
import mdsd.rPG.Relations;
import mdsd.rPG.Sub;
import mdsd.rPG.SystemRPG;
import mdsd.rPG.Team;
import mdsd.rPG.Teams;
import mdsd.rPG.Type;
import mdsd.rPG.TypeExpression;
import mdsd.services.RPGGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RPGSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RPGGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RPGPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RPGPackage.ADD:
				sequence_Sum(context, (Add) semanticObject); 
				return; 
			case RPGPackage.ALT_ATTRIBUTE:
				sequence_AltAttribute(context, (AltAttribute) semanticObject); 
				return; 
			case RPGPackage.AND:
				if (rule == grammarAccess.getRequireRule()
						|| rule == grammarAccess.getORconditionRule()
						|| action == grammarAccess.getORconditionAccess().getOrLeftAction_1_1()
						|| rule == grammarAccess.getANDconditionRule()
						|| action == grammarAccess.getANDconditionAccess().getAndLeftAction_1_1()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ANDcondition(context, (And) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEffectRule()
						|| rule == grammarAccess.getAttributeValuesRule()
						|| rule == grammarAccess.getRuleRule()) {
					sequence_ANDcondition_Rule(context, (And) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getTeamsRule()) {
					sequence_ANDcondition_Teams(context, (And) semanticObject); 
					return; 
				}
				else break;
			case RPGPackage.ATOMIC_ATTRIBUTE:
				sequence_AtomicAttribute(context, (AtomicAttribute) semanticObject); 
				return; 
			case RPGPackage.ATOMIC_NUMBER:
				if (rule == grammarAccess.getAttributeValuesRule()
						|| rule == grammarAccess.getSumRule()
						|| action == grammarAccess.getSumAccess().getAddLeftAction_1_0_0_1()
						|| action == grammarAccess.getSumAccess().getSubLeftAction_1_0_1_1()
						|| rule == grammarAccess.getMultiplyRule()
						|| action == grammarAccess.getMultiplyAccess().getMultLeftAction_1_0_0_1()
						|| action == grammarAccess.getMultiplyAccess().getDivLeftAction_1_0_1_1()
						|| rule == grammarAccess.getAtomicAttributeRule()
						|| rule == grammarAccess.getAtomicNumberRule()) {
					sequence_AtomicNumber(context, (AtomicNumber) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBattleSizeRule()) {
					sequence_AtomicNumber_BattleSize(context, (AtomicNumber) semanticObject); 
					return; 
				}
				else break;
			case RPGPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case RPGPackage.ATTRIBUTE_VALUES:
				sequence_AttributeValues(context, (AttributeValues) semanticObject); 
				return; 
			case RPGPackage.ATTRIBUTES:
				sequence_Attributes(context, (Attributes) semanticObject); 
				return; 
			case RPGPackage.DEATH:
				sequence_Death(context, (Death) semanticObject); 
				return; 
			case RPGPackage.DIV:
				sequence_Multiply(context, (Div) semanticObject); 
				return; 
			case RPGPackage.ETYPE:
				sequence_EType(context, (EType) semanticObject); 
				return; 
			case RPGPackage.ENTITIES:
				sequence_Entities(context, (Entities) semanticObject); 
				return; 
			case RPGPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case RPGPackage.ENTITY_MOVES:
				sequence_EntityMoves(context, (EntityMoves) semanticObject); 
				return; 
			case RPGPackage.LOC:
				sequence_Loc(context, (Loc) semanticObject); 
				return; 
			case RPGPackage.LOCATIONS:
				sequence_Locations(context, (Locations) semanticObject); 
				return; 
			case RPGPackage.MEMBERS:
				sequence_Members(context, (Members) semanticObject); 
				return; 
			case RPGPackage.MOVE:
				sequence_Move(context, (Move) semanticObject); 
				return; 
			case RPGPackage.MOVES:
				sequence_Moves(context, (Moves) semanticObject); 
				return; 
			case RPGPackage.MULT:
				sequence_Multiply(context, (Mult) semanticObject); 
				return; 
			case RPGPackage.OR:
				if (rule == grammarAccess.getRequireRule()
						|| rule == grammarAccess.getORconditionRule()
						|| action == grammarAccess.getORconditionAccess().getOrLeftAction_1_1()
						|| rule == grammarAccess.getANDconditionRule()
						|| action == grammarAccess.getANDconditionAccess().getAndLeftAction_1_1()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ORcondition(context, (Or) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEffectRule()
						|| rule == grammarAccess.getAttributeValuesRule()
						|| rule == grammarAccess.getRuleRule()) {
					sequence_ORcondition_Rule(context, (Or) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getTeamsRule()) {
					sequence_ORcondition_Teams(context, (Or) semanticObject); 
					return; 
				}
				else break;
			case RPGPackage.PROPOSITION:
				if (rule == grammarAccess.getNumberComparingRule()) {
					sequence_NumberComparing(context, (Proposition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEffectRule()
						|| rule == grammarAccess.getAttributeValuesRule()
						|| rule == grammarAccess.getRuleRule()) {
					sequence_NumberComparing_Rule_Statement(context, (Proposition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRequireRule()
						|| rule == grammarAccess.getORconditionRule()
						|| action == grammarAccess.getORconditionAccess().getOrLeftAction_1_1()
						|| rule == grammarAccess.getANDconditionRule()
						|| action == grammarAccess.getANDconditionAccess().getAndLeftAction_1_1()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_NumberComparing_Statement(context, (Proposition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getTeamsRule()) {
					sequence_NumberComparing_Statement_Teams(context, (Proposition) semanticObject); 
					return; 
				}
				else break;
			case RPGPackage.RELATIONS:
				sequence_Relations(context, (Relations) semanticObject); 
				return; 
			case RPGPackage.SUB:
				sequence_Sum(context, (Sub) semanticObject); 
				return; 
			case RPGPackage.SYSTEM_RPG:
				sequence_SystemRPG(context, (SystemRPG) semanticObject); 
				return; 
			case RPGPackage.TEAM:
				sequence_Team(context, (Team) semanticObject); 
				return; 
			case RPGPackage.TEAMS:
				sequence_Teams(context, (Teams) semanticObject); 
				return; 
			case RPGPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case RPGPackage.TYPE_EXPRESSION:
				sequence_TypeExpression(context, (TypeExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Require returns And
	 *     ORcondition returns And
	 *     ORcondition.Or_1_1 returns And
	 *     ANDcondition returns And
	 *     ANDcondition.And_1_1 returns And
	 *     Statement returns And
	 *
	 * Constraint:
	 *     (left=ANDcondition_And_1_1 right=Statement)
	 */
	protected void sequence_ANDcondition(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getANDconditionAccess().getAndLeftAction_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getANDconditionAccess().getRightStatementParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Effect returns And
	 *     AttributeValues returns And
	 *     Rule returns And
	 *
	 * Constraint:
	 *     (left=ANDcondition_And_1_1 right=Statement (attritbuteToSet+=[Attribute|ID] change+=Sum+)*)
	 */
	protected void sequence_ANDcondition_Rule(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns And
	 *     Teams returns And
	 *
	 * Constraint:
	 *     (left=ANDcondition_And_1_1 right=Statement bs=BattleSize team+=Team+)
	 */
	protected void sequence_ANDcondition_Teams(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AltAttribute returns AltAttribute
	 *
	 * Constraint:
	 *     (attribute=[Attribute|ID] av=AttributeValues?)
	 */
	protected void sequence_AltAttribute(ISerializationContext context, AltAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns AtomicAttribute
	 *     Sum.Add_1_0_0_1 returns AtomicAttribute
	 *     Sum.Sub_1_0_1_1 returns AtomicAttribute
	 *     Multiply returns AtomicAttribute
	 *     Multiply.Mult_1_0_0_1 returns AtomicAttribute
	 *     Multiply.Div_1_0_1_1 returns AtomicAttribute
	 *     AtomicAttribute returns AtomicAttribute
	 *
	 * Constraint:
	 *     attribute=[Attribute|ID]
	 */
	protected void sequence_AtomicAttribute(ISerializationContext context, AtomicAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.ATOMIC_ATTRIBUTE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.ATOMIC_ATTRIBUTE__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAttributeAccess().getAttributeAttributeIDTerminalRuleCall_1_1_0_1(), semanticObject.eGet(RPGPackage.Literals.ATOMIC_ATTRIBUTE__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeValues returns AtomicNumber
	 *     Sum returns AtomicNumber
	 *     Sum.Add_1_0_0_1 returns AtomicNumber
	 *     Sum.Sub_1_0_1_1 returns AtomicNumber
	 *     Multiply returns AtomicNumber
	 *     Multiply.Mult_1_0_0_1 returns AtomicNumber
	 *     Multiply.Div_1_0_1_1 returns AtomicNumber
	 *     AtomicAttribute returns AtomicNumber
	 *     AtomicNumber returns AtomicNumber
	 *
	 * Constraint:
	 *     (float2=Float | int2=INT)
	 */
	protected void sequence_AtomicNumber(ISerializationContext context, AtomicNumber semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BattleSize returns AtomicNumber
	 *
	 * Constraint:
	 *     ((float2=Float | int2=INT) req=Require?)
	 */
	protected void sequence_AtomicNumber_BattleSize(ISerializationContext context, AtomicNumber semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeValues returns AttributeValues
	 *
	 * Constraint:
	 *     lTypes=LegalType
	 */
	protected void sequence_AttributeValues(ISerializationContext context, AttributeValues semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.ATTRIBUTE_VALUES__LTYPES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.ATTRIBUTE_VALUES__LTYPES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeValuesAccess().getLTypesLegalTypeParserRuleCall_0_1_0_0(), semanticObject.getLTypes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID aVal=AttributeValues)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.ATTRIBUTE__AVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.ATTRIBUTE__AVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getAValAttributeValuesParserRuleCall_2_0(), semanticObject.getAVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Attributes
	 *     Attributes returns Attributes
	 *
	 * Constraint:
	 *     attribute+=Attribute+
	 */
	protected void sequence_Attributes(ISerializationContext context, Attributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Death
	 *     Death returns Death
	 *
	 * Constraint:
	 *     con+=ORcondition+
	 */
	protected void sequence_Death(ISerializationContext context, Death semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EType returns EType
	 *
	 * Constraint:
	 *     type=[Type|ID]
	 */
	protected void sequence_EType(ISerializationContext context, EType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.ETYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.ETYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getETypeAccess().getTypeTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RPGPackage.Literals.ETYPE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Entities
	 *     Entities returns Entities
	 *
	 * Constraint:
	 *     entity+=Entity+
	 */
	protected void sequence_Entities(ISerializationContext context, Entities semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityMoves returns EntityMoves
	 *
	 * Constraint:
	 *     move+=[Move|ID]+
	 */
	protected void sequence_EntityMoves(ISerializationContext context, EntityMoves semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=ID eType=EType att+=AltAttribute* eMoves+=EntityMoves*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Loc returns Loc
	 *
	 * Constraint:
	 *     (name=ID team=[Team|ID])
	 */
	protected void sequence_Loc(ISerializationContext context, Loc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.LOC__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.LOC__NAME));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.LOC__TEAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.LOC__TEAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocAccess().getTeamTeamIDTerminalRuleCall_2_0_1(), semanticObject.eGet(RPGPackage.Literals.LOC__TEAM, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Locations
	 *     Locations returns Locations
	 *
	 * Constraint:
	 *     loc+=Loc+
	 */
	protected void sequence_Locations(ISerializationContext context, Locations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Members returns Members
	 *
	 * Constraint:
	 *     entity+=[Entity|ID]+
	 */
	protected void sequence_Members(ISerializationContext context, Members semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Move returns Move
	 *
	 * Constraint:
	 *     (name=ID eType=EType? att+=AltAttribute* effect+=Effect*)
	 */
	protected void sequence_Move(ISerializationContext context, Move semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Moves
	 *     Moves returns Moves
	 *
	 * Constraint:
	 *     move+=Move+
	 */
	protected void sequence_Moves(ISerializationContext context, Moves semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns Div
	 *     Sum.Add_1_0_0_1 returns Div
	 *     Sum.Sub_1_0_1_1 returns Div
	 *     Multiply returns Div
	 *     Multiply.Mult_1_0_0_1 returns Div
	 *     Multiply.Div_1_0_1_1 returns Div
	 *
	 * Constraint:
	 *     (left=Multiply_Div_1_0_1_1 right=AtomicAttribute)
	 */
	protected void sequence_Multiply(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplyAccess().getDivLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplyAccess().getRightAtomicAttributeParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns Mult
	 *     Sum.Add_1_0_0_1 returns Mult
	 *     Sum.Sub_1_0_1_1 returns Mult
	 *     Multiply returns Mult
	 *     Multiply.Mult_1_0_0_1 returns Mult
	 *     Multiply.Div_1_0_1_1 returns Mult
	 *
	 * Constraint:
	 *     (left=Multiply_Mult_1_0_0_1 right=AtomicAttribute)
	 */
	protected void sequence_Multiply(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplyAccess().getMultLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplyAccess().getRightAtomicAttributeParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumberComparing returns Proposition
	 *
	 * Constraint:
	 *     (left=Sum comp=Comparator right=Sum)
	 */
	protected void sequence_NumberComparing(ISerializationContext context, Proposition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__COMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__COMP));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberComparingAccess().getLeftSumParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNumberComparingAccess().getCompComparatorParserRuleCall_1_0(), semanticObject.getComp());
		feeder.accept(grammarAccess.getNumberComparingAccess().getRightSumParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Effect returns Proposition
	 *     AttributeValues returns Proposition
	 *     Rule returns Proposition
	 *
	 * Constraint:
	 *     ((type=[Type|ID] | (left=Sum comp=Comparator right=Sum)) (attritbuteToSet+=[Attribute|ID] change+=Sum+)*)
	 */
	protected void sequence_NumberComparing_Rule_Statement(ISerializationContext context, Proposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Require returns Proposition
	 *     ORcondition returns Proposition
	 *     ORcondition.Or_1_1 returns Proposition
	 *     ANDcondition returns Proposition
	 *     ANDcondition.And_1_1 returns Proposition
	 *     Statement returns Proposition
	 *
	 * Constraint:
	 *     (type=[Type|ID] | (left=Sum comp=Comparator right=Sum))
	 */
	protected void sequence_NumberComparing_Statement(ISerializationContext context, Proposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Proposition
	 *     Teams returns Proposition
	 *
	 * Constraint:
	 *     ((type=[Type|ID] | (left=Sum comp=Comparator right=Sum)) bs=BattleSize team+=Team+)
	 */
	protected void sequence_NumberComparing_Statement_Teams(ISerializationContext context, Proposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Require returns Or
	 *     ORcondition returns Or
	 *     ORcondition.Or_1_1 returns Or
	 *     ANDcondition returns Or
	 *     ANDcondition.And_1_1 returns Or
	 *     Statement returns Or
	 *
	 * Constraint:
	 *     (left=ORcondition_Or_1_1 right=ANDcondition)
	 */
	protected void sequence_ORcondition(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getORconditionAccess().getOrLeftAction_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getORconditionAccess().getRightANDconditionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Effect returns Or
	 *     AttributeValues returns Or
	 *     Rule returns Or
	 *
	 * Constraint:
	 *     (left=ORcondition_Or_1_1 right=ANDcondition (attritbuteToSet+=[Attribute|ID] change+=Sum+)*)
	 */
	protected void sequence_ORcondition_Rule(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Or
	 *     Teams returns Or
	 *
	 * Constraint:
	 *     (left=ORcondition_Or_1_1 right=ANDcondition bs=BattleSize team+=Team+)
	 */
	protected void sequence_ORcondition_Teams(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Relations
	 *     Relations returns Relations
	 *
	 * Constraint:
	 *     type+=Type+
	 */
	protected void sequence_Relations(ISerializationContext context, Relations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns Add
	 *     Sum.Add_1_0_0_1 returns Add
	 *     Sum.Sub_1_0_1_1 returns Add
	 *
	 * Constraint:
	 *     (left=Sum_Add_1_0_0_1 right=Multiply)
	 */
	protected void sequence_Sum(ISerializationContext context, Add semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getAddLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSumAccess().getRightMultiplyParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sum returns Sub
	 *     Sum.Add_1_0_0_1 returns Sub
	 *     Sum.Sub_1_0_1_1 returns Sub
	 *
	 * Constraint:
	 *     (left=Sum_Sub_1_0_1_1 right=Multiply)
	 */
	protected void sequence_Sum(ISerializationContext context, Sub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RPGPackage.Literals.PROPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getSubLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSumAccess().getRightMultiplyParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SystemRPG returns SystemRPG
	 *
	 * Constraint:
	 *     (name=ID declarations+=Declaration*)
	 */
	protected void sequence_SystemRPG(ISerializationContext context, SystemRPG semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Team returns Team
	 *
	 * Constraint:
	 *     (name=ID members+=Members+)
	 */
	protected void sequence_Team(ISerializationContext context, Team semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Teams
	 *     Teams returns Teams
	 *
	 * Constraint:
	 *     (bs=BattleSize team+=Team+)
	 */
	protected void sequence_Teams(ISerializationContext context, Teams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeExpression returns TypeExpression
	 *
	 * Constraint:
	 *     (strong=[Type|ID] strong2+=[Type|ID]* currentT=[Type|ID] weak=[Type|ID] weak2+=[Type|ID]*)
	 */
	protected void sequence_TypeExpression(ISerializationContext context, TypeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (name=ID tExpression=TypeExpression?)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
